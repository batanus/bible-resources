name: Update Bible Resources Registry

on:
  schedule:
    # Runs every day at 07:00 UTC (approximately 10:00 Chisinau time)
    - cron: '0 7 * * *'
  workflow_dispatch: # Allows manual trigger

jobs:
  update-registry:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Download registry with fallback hosts
        run: |
          echo "Downloading registry.zip with fallback support..."
          
          # List of registry hosts (in priority order)
          REGISTRY_HOSTS=(
            "https://mybible.zone/repository/registry/registry.zip"
            "http://mybible.infoo.pro/registry.zip"
            "http://mph4.ru/registry.zip"
            "http://myb.1gb.ru/registry.zip"
          )
          
          DOWNLOADED=false
          
          for HOST_URL in "${REGISTRY_HOSTS[@]}"; do
            echo ""
            echo "Trying: $HOST_URL"
            
            # Try to download with 30 second timeout
            if curl -L -f -o /tmp/registry.zip "$HOST_URL" --connect-timeout 30 --max-time 30 2>/dev/null; then
              echo "‚úÖ Successfully downloaded registry.zip from $HOST_URL"
              DOWNLOADED=true
              break
            else
              echo "‚ùå Failed to download from $HOST_URL"
            fi
          done
          
          if [ "$DOWNLOADED" = false ]; then
            echo "‚ùå Failed to download registry.zip from all hosts"
            exit 1
          fi
          
          echo ""
          echo "‚úÖ Registry download completed"
          
      - name: Extract and compare registry
        id: check_changes
        run: |
          echo "Extracting registry.zip..."
          unzip -o /tmp/registry.zip -d /tmp/
          
          # Check if registry.json was extracted
          if [ ! -f /tmp/registry.json ]; then
            echo "Error: registry.json not found in archive"
            exit 1
          fi
          
          echo "Comparing registries..."
          
          # Install jq for JSON processing (silently)
          sudo apt-get update -qq && sudo apt-get install -y jq -qq > /dev/null 2>&1
          
          # Compare registries using JSON structure, not text
          python3 << 'PYTHON_COMPARE'
          import json
          import sys
          
          # Load both registries
          try:
              with open('registry.json', 'r', encoding='utf-8-sig') as f:
                  old_registry = json.load(f)
          except FileNotFoundError:
              old_registry = {'downloads': [], 'hosts': []}
          
          with open('/tmp/registry.json', 'r', encoding='utf-8-sig') as f:
              new_registry = json.load(f)
          
          # Compare versions
          old_version = old_registry.get('version', 0)
          new_version = new_registry.get('version', 0)
          
          # Compare hosts (ignore order)
          old_hosts = {h['alias']: h for h in old_registry.get('hosts', [])}
          new_hosts = {h['alias']: h for h in new_registry.get('hosts', [])}
          
          # Compare modules
          old_modules = {item['abr']: item for item in old_registry.get('downloads', [])}
          new_modules = {item['abr']: item for item in new_registry.get('downloads', [])}
          
          # Check for actual changes
          has_changes = False
          change_reasons = []
          
          # Version change
          if old_version != new_version:
              has_changes = True
              change_reasons.append(f"Version: {old_version} ‚Üí {new_version}")
          
          # New hosts
          new_host_aliases = set(new_hosts.keys()) - set(old_hosts.keys())
          if new_host_aliases:
              has_changes = True
              change_reasons.append(f"New hosts: {', '.join(new_host_aliases)}")
          
          # New modules
          new_module_ids = set(new_modules.keys()) - set(old_modules.keys())
          if new_module_ids:
              has_changes = True
              change_reasons.append(f"New modules: {len(new_module_ids)}")
          
          # Updated modules (check metadata, not URLs)
          updated_modules = []
          for abr in set(new_modules.keys()) & set(old_modules.keys()):
              old_mod = old_modules[abr]
              new_mod = new_modules[abr]
              
              # Compare only metadata fields (not URLs)
              metadata_changed = (
                  old_mod.get('des') != new_mod.get('des') or
                  old_mod.get('upd') != new_mod.get('upd') or
                  old_mod.get('lng') != new_mod.get('lng') or
                  old_mod.get('fil') != new_mod.get('fil') or
                  old_mod.get('siz') != new_mod.get('siz')
              )
              
              if metadata_changed:
                  updated_modules.append(abr)
          
          if updated_modules:
              has_changes = True
              change_reasons.append(f"Updated modules: {len(updated_modules)}")
          
          # Output result
          if has_changes:
              print("‚úÖ Changes detected in registry")
              
              with open('/tmp/has_changes.txt', 'w') as f:
                  f.write('true')
          else:
              print("‚ÑπÔ∏è No changes detected")
              with open('/tmp/has_changes.txt', 'w') as f:
                  f.write('false')
          PYTHON_COMPARE
          
          # Read result
          HAS_CHANGES=$(cat /tmp/has_changes.txt)
          echo "has_changes=$HAS_CHANGES" >> $GITHUB_OUTPUT
          
          if [ "$HAS_CHANGES" = "true" ]; then
            # Find new or updated modules
            python3 << 'PYTHON_SCRIPT'
          import json
          import sys
          import os
          
          # Load old and new registries
          try:
              with open('registry.json', 'r', encoding='utf-8-sig') as f:
                  old_registry = json.load(f)
          except FileNotFoundError:
              old_registry = {'downloads': []}
          
          with open('/tmp/registry.json', 'r', encoding='utf-8-sig') as f:
              new_registry = json.load(f)
          
          # Create lookup dictionaries
          old_modules = {item['abr']: item for item in old_registry.get('downloads', [])}
          new_modules = {item['abr']: item for item in new_registry.get('downloads', [])}
          
          # Find new and updated modules
          new_items = []
          updated_items = []
          
          for abr, new_item in new_modules.items():
              if abr not in old_modules:
                  new_items.append(abr)
              elif old_modules[abr].get('upd') != new_item.get('upd'):
                  updated_items.append(abr)
          
          print(f"üìä Analysis: {len(old_modules)} old modules, {len(new_modules)} new modules")
          print(f"üìä Found: {len(new_items)} new, {len(updated_items)} updated")
          
          # Save list of modules to download
          modules_to_download = new_items + updated_items
          
          # Write modules list to GITHUB_OUTPUT
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              if modules_to_download:
                  # Save as comma-separated string
                  modules_str = ','.join(modules_to_download)
                  f.write(f"modules_list={modules_str}\n")
                  f.write(f"modules_count={len(modules_to_download)}\n")
                  
                  print(f"üì¶ Modules to download ({len(modules_to_download)}): {', '.join(modules_to_download[:10])}")
                  if len(modules_to_download) > 10:
                      print(f"   ... and {len(modules_to_download) - 10} more")
              else:
                  f.write(f"modules_list=\n")
                  f.write(f"modules_count=0\n")
                  print("‚ÑπÔ∏è No new or updated modules found")
          
          # Create summary for PR
          summary = []
          summary.append(f"## Registry Update Summary\n")
          summary.append(f"- **New modules:** {len(new_items)}")
          summary.append(f"- **Updated modules:** {len(updated_items)}")
          summary.append(f"- **Total changes:** {len(modules_to_download)}\n")
          
          if new_items:
              summary.append("### üì¶ New Modules\n")
              for item in new_items[:20]:  # Show first 20
                  mod = new_modules[item]
                  summary.append(f"- `{item}` - {mod.get('des', 'No description')}")
              if len(new_items) > 20:
                  summary.append(f"\n_...and {len(new_items) - 20} more_\n")
          
          if updated_items:
              summary.append("\n### üîÑ Updated Modules\n")
              for item in updated_items[:20]:  # Show first 20
                  mod = new_modules[item]
                  summary.append(f"- `{item}` - {mod.get('des', 'No description')}")
              if len(updated_items) > 20:
                  summary.append(f"\n_...and {len(updated_items) - 20} more_\n")
          
          if not modules_to_download:
              summary.append("\n### ‚ÑπÔ∏è Note\n")
              summary.append("Registry metadata updated (version, hosts, etc.) but no module downloads required.\n")
          
          with open('/tmp/pr_summary.md', 'w') as f:
              f.write('\n'.join(summary))
          PYTHON_SCRIPT
          else
            echo "No changes detected - skipping module download"
            echo "has_changes=false" >> $GITHUB_OUTPUT
          fi
          
      - name: Update registry.json
        if: steps.check_changes.outputs.has_changes == 'true'
        run: |
          echo "Merging registries (preserve custom hosts and URLs)..."
          
          python3 << 'PYTHON_MERGE'
          import json
          import re
          
          # Load old registry (with custom hosts and URLs)
          with open('registry.json', 'r', encoding='utf-8-sig') as f:
              old_registry = json.load(f)
          
          # Load new registry (from external source)
          with open('/tmp/registry.json', 'r', encoding='utf-8-sig') as f:
              new_registry = json.load(f)
          
          # Merge strategy:
          # 1. Keep old hosts + add any new hosts from external source
          # 2. Update module metadata (des, upd, lng, etc.) from new registry
          # 3. Keep old URLs for existing modules, add CDN URLs + external URLs for new modules
          
          # Step 1: Merge hosts
          old_hosts = {h['alias']: h for h in old_registry.get('hosts', [])}
          new_hosts = {h['alias']: h for h in new_registry.get('hosts', [])}
          
          # Add new hosts that don't exist in old registry
          merged_hosts = list(old_hosts.values())
          for alias, host in new_hosts.items():
              if alias not in old_hosts:
                  merged_hosts.append(host)
          
          # Helper function to parse size string (e.g., "45.2M", "1.5K", "123")
          def parse_size_mb(size_str):
              """Parse size string and return size in MB"""
              if not size_str:
                  return 0
              
              size_str = str(size_str).strip().upper()
              
              # Extract number and unit
              match = re.match(r'^([\d.]+)\s*([KMG]?)$', size_str)
              if not match:
                  return 0
              
              value = float(match.group(1))
              unit = match.group(2)
              
              # Convert to MB
              if unit == 'K':
                  return value / 1024  # KB to MB
              elif unit == 'M':
                  return value
              elif unit == 'G':
                  return value * 1024  # GB to MB
              else:
                  # Assume bytes
                  return value / (1024 * 1024)
          
          # Step 2: Merge modules
          old_modules = {item['abr']: item for item in old_registry.get('downloads', [])}
          new_modules = {item['abr']: item for item in new_registry.get('downloads', [])}
          
          merged_downloads = []
          
          for abr, new_module in new_modules.items():
              if abr in old_modules:
                  # Existing module: update metadata but keep URLs
                  old_module = old_modules[abr]
                  merged_module = new_module.copy()
                  
                  # Preserve old URLs if they exist
                  if 'url' in old_module:
                      merged_module['url'] = old_module['url']
                  
                  merged_downloads.append(merged_module)
              else:
                  # New module: add CDN URLs at the beginning
                  merged_module = new_module.copy()
                  
                  # Get module filename
                  module_file = merged_module.get('fil', '')
                  
                  # Get module size and parse it
                  size_str = merged_module.get('siz', '0')
                  size_mb = parse_size_mb(size_str)
                  
                  # Prepare CDN URLs to prepend
                  cdn_urls = []
                  
                  # Only add {cdn} if size is less than or equal to 50MB
                  if size_mb <= 50:
                      cdn_urls.append(f"{{cdn}}{module_file}")
                  
                  # Always add {cdn2} and {gh}
                  cdn_urls.append(f"{{cdn2}}{module_file}")
                  cdn_urls.append(f"{{gh}}{module_file}")
                  
                  # Get existing URLs from external source
                  existing_urls = merged_module.get('url', [])
                  
                  # Prepend CDN URLs to the beginning
                  merged_module['url'] = cdn_urls + existing_urls
                  
                  print(f"‚úÖ Added new module: {abr}")
                  
                  merged_downloads.append(merged_module)
          
          # Create merged registry
          merged_registry = {
              'version': new_registry.get('version', old_registry.get('version', 0)),
              'hosts': merged_hosts,
              'downloads': merged_downloads
          }
          
          # Save merged registry with formatting
          with open('registry.json', 'w', encoding='utf-8') as f:
              json.dump(merged_registry, f, ensure_ascii=False, indent=2)
              f.write('\n')
          
          print(f"‚úÖ Registry merged: {len(merged_hosts)} hosts, {len(merged_downloads)} modules")
          PYTHON_MERGE
          
      - name: Download new/updated modules
        if: steps.check_changes.outputs.has_changes == 'true' && steps.check_changes.outputs.modules_count != '0'
        run: |
          echo "Downloading new and updated modules..."
          
          # Install jq if not already installed (silently)
          sudo apt-get update -qq && sudo apt-get install -y jq -qq > /dev/null 2>&1
          
          # Read modules list from output
          MODULES_LIST="${{ steps.check_changes.outputs.modules_list }}"
          
          if [ -z "$MODULES_LIST" ]; then
            echo "‚ö†Ô∏è  Module list is empty"
            echo ""
            echo "========================================="
            echo "DOWNLOAD SUMMARY"
            echo "========================================="
            echo "Total modules:      0"
            echo "Successfully downloaded: 0"
            echo "Failed downloads:   0"
            echo "Success rate:       N/A"
            echo "========================================="
            exit 0
          fi
          
          # Convert comma-separated string to array
          IFS=',' read -ra MODULES_ARRAY <<< "$MODULES_LIST"
          
          echo "üìã Modules to download: ${#MODULES_ARRAY[@]} total"
          for i in "${!MODULES_ARRAY[@]}"; do
            if [ $i -lt 5 ]; then
              echo "  - ${MODULES_ARRAY[$i]}"
            fi
          done
          if [ ${#MODULES_ARRAY[@]} -gt 5 ]; then
            echo "  ... and $((${#MODULES_ARRAY[@]} - 5)) more"
          fi
          echo ""
          
          # Use the ORIGINAL external registry (not the merged one with CDN URLs)
          # because CDN files don't exist yet until this PR is merged
          NEW_REGISTRY="/tmp/registry.json"
          
          # Create modules directory if it doesn't exist
          mkdir -p modules
          
          # Statistics
          TOTAL_MODULES=0
          SUCCESS_COUNT=0
          FAILED_COUNT=0
          
          # Download each module from the array
          for module_abr in "${MODULES_ARRAY[@]}"; do
            [ -z "$module_abr" ] && continue
            
            echo ""
            echo "========================================="
            echo "Processing module: $module_abr"
            TOTAL_MODULES=$((TOTAL_MODULES + 1))
            
            # Find the module in the new registry
            MODULE_DATA=$(jq -r --arg abr "$module_abr" '.downloads[] | select(.abr == $abr)' "$NEW_REGISTRY")
            
            if [ -z "$MODULE_DATA" ]; then
              echo "‚ùå Module $module_abr not found in registry"
              FAILED_COUNT=$((FAILED_COUNT + 1))
              continue
            fi
            
            # Get module filename
            MODULE_FILE=$(echo "$MODULE_DATA" | jq -r '.fil')
            OUTPUT_FILE="modules/${MODULE_FILE}.zip"
            
            # Get ALL URLs from the module's url array
            URL_ARRAY=$(echo "$MODULE_DATA" | jq -r '.url[]' 2>/dev/null || echo "")
            
            if [ -z "$URL_ARRAY" ]; then
              echo "‚ùå No URLs found for module $module_abr"
              FAILED_COUNT=$((FAILED_COUNT + 1))
              continue
            fi
            
            URL_COUNT=$(echo "$URL_ARRAY" | wc -l | tr -d ' ')
            echo "Found $URL_COUNT URL(s) for this module"
            
            # Try each URL until one succeeds
            url_index=0
            download_success=false
            
            while IFS= read -r MODULE_URL; do
              [ -z "$MODULE_URL" ] && continue
              url_index=$((url_index + 1))
              
              echo ""
              echo "Trying URL #$url_index: $MODULE_URL"
              
              # Resolve URL: check if it starts with http (direct URL) or needs alias resolution
              if [[ "$MODULE_URL" == http* ]]; then
                # Direct URL, no resolution needed
                DOWNLOAD_URL="$MODULE_URL"
              else
                # Extract alias and filename from template like "{cdn}100EJ-p.plan"
                DOWNLOAD_URL=""
                
                # Read hosts and find matching alias
                while IFS= read -r host_line; do
                  alias=$(echo "$host_line" | jq -r '.alias')
                  path=$(echo "$host_line" | jq -r '.path')
                  
                  # Remove curly braces from alias
                  clean_alias=$(echo "$alias" | tr -d '{}')
                  alias_pattern="{$clean_alias}"
                  
                  # Check if this alias is in the URL
                  if [[ "$MODULE_URL" == *"$alias_pattern"* ]]; then
                    # Extract filename by removing the alias pattern
                    filename=$(echo "$MODULE_URL" | sed "s|$alias_pattern||g")
                    # Replace %s in path with the filename
                    DOWNLOAD_URL=$(echo "$path" | sed "s|%s|$filename|g")
                    break
                  fi
                done < <(jq -c '.hosts[]' "$NEW_REGISTRY")
                
                # If no match found, skip this URL
                if [ -z "$DOWNLOAD_URL" ]; then
                  echo "  ‚ö†Ô∏è  Could not resolve URL pattern: $MODULE_URL"
                  continue
                fi
              fi
              
              echo "Resolved URL: $DOWNLOAD_URL"
              
              # Try to download with retries for this specific URL
              max_attempts=3
              attempt=1
              
              while [ $attempt -le $max_attempts ]; do
                echo "  üì• Downloading from: $DOWNLOAD_URL"
                
                if curl -L -f -o "$OUTPUT_FILE" "$DOWNLOAD_URL" --connect-timeout 30 --max-time 300 2>/dev/null; then
                  echo "  ‚úÖ Successfully downloaded from URL #$url_index"
                  download_success=true
                  break 2  # Exit both retry loop and URL loop
                else
                  echo "  ‚ùå Failed (attempt $attempt/$max_attempts)"
                  if [ $attempt -lt $max_attempts ]; then
                    sleep 5
                  fi
                  attempt=$((attempt + 1))
                fi
              done
              
              echo "  ‚ö†Ô∏è  All attempts failed for URL #$url_index, trying next URL..."
            done <<< "$URL_ARRAY"
            
            # Check final result for this module
            if [ "$download_success" = true ] && [ -f "$OUTPUT_FILE" ]; then
              file_size=$(ls -lh "$OUTPUT_FILE" | awk '{print $5}')
              echo ""
              echo "‚úÖ Module $module_abr downloaded successfully ($file_size)"
              SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
            else
              echo ""
              echo "‚ùå Failed to download $module_abr from all available URLs"
              FAILED_COUNT=$((FAILED_COUNT + 1))
              # Clean up partial downloads
              rm -f "$OUTPUT_FILE"
            fi
            
          done
          
          # Print summary
          echo ""
          echo "========================================="
          echo "DOWNLOAD SUMMARY"
          echo "========================================="
          echo "Total modules:      $TOTAL_MODULES"
          echo "Successfully downloaded: $SUCCESS_COUNT"
          echo "Failed downloads:   $FAILED_COUNT"
          if [ $TOTAL_MODULES -gt 0 ]; then
            echo "Success rate:       $(awk "BEGIN {printf \"%.1f%%\", ($SUCCESS_COUNT/$TOTAL_MODULES)*100}")"
          else
            echo "Success rate:       N/A"
          fi
          echo "========================================="
          
          # Save summary for PR
          if [ $TOTAL_MODULES -gt 0 ]; then
            cat >> /tmp/pr_summary.md << EOF
          
          ## üìä Download Statistics
          
          - **Total modules processed:** $TOTAL_MODULES
          - **Successfully downloaded:** $SUCCESS_COUNT ‚úÖ
          - **Failed downloads:** $FAILED_COUNT ‚ùå
          - **Success rate:** $(awk "BEGIN {printf \"%.1f%%\", ($SUCCESS_COUNT/$TOTAL_MODULES)*100}")
          EOF
          fi
          
      - name: Recreate registry.zip with formatted registry
        if: steps.check_changes.outputs.has_changes == 'true'
        run: |
          echo "Rebuilding registry.zip from formatted registry.json..."
          rm -f registry.zip
          zip -j registry.zip registry.json
          
      - name: Update registry statistics
        if: steps.check_changes.outputs.has_changes == 'true'
        run: |
          python3 << 'PYTHON_SCRIPT'
          import json
          import os
          from pathlib import Path
          
          # Load registry
          with open('registry.json', 'r', encoding='utf-8-sig') as f:
              registry = json.load(f)
          
          # Count modules
          total_modules = len(registry.get('downloads', []))
          
          # Calculate total size
          modules_dir = Path('modules')
          total_size = 0
          if modules_dir.exists():
              for file_path in modules_dir.glob('*.zip'):
                  total_size += file_path.stat().st_size
          
          # Convert to GB
          size_gb = total_size / (1024 ** 3)
          
          # Count unique languages
          languages = set()
          for item in registry.get('downloads', []):
              if 'lng' in item:
                  languages.add(item['lng'])
          
          print(f"üìä Statistics: {total_modules} modules, {size_gb:.1f} GB, {len(languages)} languages")
          
          # Save stats for README update
          with open('/tmp/stats.txt', 'w') as f:
              f.write(f"{total_modules}\n")
              f.write(f"{size_gb:.1f}\n")
              f.write(f"{len(languages)}\n")
          PYTHON_SCRIPT
          
      - name: Create Pull Request
        if: steps.check_changes.outputs.has_changes == 'true'
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: 'chore: update registry and modules'
          title: 'üîÑ Registry Update - ${{ github.run_number }}'
          body-path: /tmp/pr_summary.md
          branch: registry-update-${{ github.run_number }}
          delete-branch: true
          labels: |
            automated
            registry-update
          add-paths: |
            registry.json
            registry.zip
            modules/*.zip
          
      - name: Summary
        if: always()
        run: |
          if [ "${{ steps.check_changes.outputs.has_changes }}" = "true" ]; then
            echo "‚úÖ Registry update completed. Pull request created."
          else
            echo "‚ÑπÔ∏è No changes detected in registry."
          fi
